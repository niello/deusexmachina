//#pragma once
//#ifndef __DEM_L1_RENDER_SHADER_H__
//#define __DEM_L1_RENDER_SHADER_H__
//
//#include <Render/Materials/Texture.h>
//#include <Events/EventsFwd.h>
//#include <Events/Subscription.h>
//#include <Data/Data.h>
//#include <Data/Dictionary.h>
//
//// Encapsulates graphics hardware shader (in different variations) and associated variable mapping
//
//// Docs: handles generated by different instances of ID3DXEffect and ID3DXEffectCompiler will be different.
//
//namespace IO
//{
//	class CStream;
//}
//
//namespace Render
//{
//
//class CShader: public Resources::CResource
//{
//	__DeclareClass(CShader);
//
//public:
//
//	typedef D3DXHANDLE HVar;
//	typedef D3DXHANDLE HTech;
//
//protected:
//
//	ID3DXEffect*		pEffect;
//
//	//CDict<CStrID, HTech>	NameToTech;
//	CDict<DWORD, HTech>	FlagsToTech;
//	HTech				hCurrTech;
//
//	//???!!!need both?!
//	CDict<CStrID, HVar>	NameToHVar;
//	CDict<CStrID, HVar>	SemanticToHVar;
//
//	DECLARE_EVENT_HANDLER(OnRenderDeviceLost, OnDeviceLost);
//	DECLARE_EVENT_HANDLER(OnRenderDeviceReset, OnDeviceReset);
//
//public:
//
//	CShader(CStrID ID): CResource(ID), pEffect(NULL), hCurrTech(NULL), FlagsToTech(0, 4, true) {}
//	virtual ~CShader() { if (IsLoaded()) Unload(); }
//
//	bool			Setup(ID3DXEffect* pFX);
//	virtual void	Unload();
//
//	bool			Set(HVar Var, const Data::CData& Value);
//	void			SetBool(HVar Var, bool Value);
//	void			SetInt(HVar Var, int Value);
//	void			SetIntArray(HVar Var, const int* pArray, DWORD Count);
//	void			SetFloat(HVar Var, float Value);
//	void			SetFloatArray(HVar Var, const float* pArray, DWORD Count);
//	void			SetFloat4(HVar Var, const vector4& Value);
//	void			SetFloat4Array(HVar Var, const vector4* pArray, DWORD Count);
//	void			SetMatrix(HVar Var, const matrix44& Value);
//	void			SetMatrixArray(HVar Var, const matrix44* pArray, DWORD Count);
//	void			SetMatrixPointerArray(HVar Var, const matrix44** pArray, DWORD Count);
//	void			SetTexture(HVar Var, const CTexture& Value);
//	//pEffect->SetRawValue
//
//	DWORD			Begin(bool SaveState);
//	void			BeginPass(DWORD PassIdx);
//	void			CommitChanges(); // For changes inside a pass
//	void			EndPass();
//	void			End();
//
//	HTech			GetTechByFeatures(DWORD FeatureFlags) const;
//	HTech			GetCurrentTech() const { return hCurrTech; }
//	bool			SetTech(HTech hTech);
//	HVar			GetVarHandleByName(CStrID Name) const;
//	HVar			GetVarHandleBySemantic(CStrID Semantic) const;
//	bool			HasVarByName(CStrID Name) const { return NameToHVar.FindIndex(Name) != INVALID_INDEX; }
//	bool			HasVarBySemantic(CStrID Semantic) const { return SemanticToHVar.FindIndex(Semantic) != INVALID_INDEX; }
//	bool			IsVarUsed(HVar hVar) const;
//	ID3DXEffect*	GetD3D9Effect() const { return pEffect; }
//};
//
//typedef Ptr<CShader> PShader;
//
//// Doesn't support arrays for now (no corresponding types)
//inline bool CShader::Set(HVar Var, const Data::CData& Value)
//{
//	n_assert_dbg(Var && Value.IsValid());
//	if (Value.IsA<bool>()) SetBool(Var, Value);
//	else if (Value.IsA<int>()) SetInt(Var, Value);
//	else if (Value.IsA<float>()) SetFloat(Var, Value);
//	else if (Value.IsA<vector4>()) SetFloat4(Var, Value);
//	else if (Value.IsA<matrix44>()) SetMatrix(Var, Value);
//	else if (Value.IsA<CMatrixPtrArray>())
//	{
//		const CMatrixPtrArray& Array = Value.GetValue<CMatrixPtrArray>();
//		SetMatrixPointerArray(Var, Array.Begin(), Array.GetCount());
//	}
//	else if (Value.IsA<PTexture>()) SetTexture(Var, *Value.GetValue<PTexture>());
//	else FAIL;
//	OK;
//}
////---------------------------------------------------------------------
//
//inline CShader::HTech CShader::GetTechByFeatures(DWORD FeatureFlags) const
//{
//	int Idx = FlagsToTech.FindIndex(FeatureFlags);
//	return(Idx == INVALID_INDEX) ? NULL : FlagsToTech.ValueAt(Idx);
//}
////---------------------------------------------------------------------
//
//inline CShader::HVar CShader::GetVarHandleByName(CStrID Name) const
//{
//	int Idx = NameToHVar.FindIndex(Name);
//	return (Idx == INVALID_INDEX) ? NULL : NameToHVar.ValueAt(Idx);
//}
////---------------------------------------------------------------------
//
//inline CShader::HVar CShader::GetVarHandleBySemantic(CStrID Semantic) const
//{
//	int Idx = NameToHVar.FindIndex(Semantic);
//	return (Idx == INVALID_INDEX) ? NULL : SemanticToHVar.ValueAt(Idx);
//}
////---------------------------------------------------------------------
//
//}
//
//#endif
