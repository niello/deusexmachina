#pragma once
#ifndef __DEM_L1_RENDER_SHADER_H__
#define __DEM_L1_RENDER_SHADER_H__

#include <Render/Materials/Texture.h>
#include <Events/EventsFwd.h>
#include <Events/Subscription.h>
#include <Data/Data.h>
#include <Data/Dictionary.h>

// Encapsulates graphics hardware shader (in different variations) and associated variable mapping

// Docs: handles generated by different instances of ID3DXEffect and ID3DXEffectCompiler will be different.

namespace IO
{
	class CStream;
}

namespace Render
{

class CShader: public Resources::CResource
{
	__DeclareClass(CShader);

public:

	typedef D3DXHANDLE HVar;
	typedef D3DXHANDLE HTech;

protected:

	ID3DXEffect*		pEffect;

	//CDict<CStrID, HTech>	NameToTech;
	CDict<DWORD, HTech>	FlagsToTech;
	HTech				hCurrTech;

	//???!!!need both?!
	CDict<CStrID, HVar>	NameToHVar;
	CDict<CStrID, HVar>	SemanticToHVar;

	DECLARE_EVENT_HANDLER(OnRenderDeviceLost, OnDeviceLost);
	DECLARE_EVENT_HANDLER(OnRenderDeviceReset, OnDeviceReset);

public:

	CShader(CStrID ID): CResource(ID), pEffect(NULL), hCurrTech(NULL), FlagsToTech(0, 4, true) {}
	virtual ~CShader() { if (IsLoaded()) Unload(); }

	bool			Setup(ID3DXEffect* pFX);
	virtual void	Unload();

	bool			Set(HVar Var, const Data::CData& Value);
	void			SetBool(HVar Var, bool Value);
	void			SetInt(HVar Var, int Value);
	void			SetIntArray(HVar Var, const int* pArray, DWORD Count);
	void			SetFloat(HVar Var, float Value);
	void			SetFloatArray(HVar Var, const float* pArray, DWORD Count);
	void			SetFloat4(HVar Var, const vector4& Value);
	void			SetFloat4Array(HVar Var, const vector4* pArray, DWORD Count);
	void			SetMatrix(HVar Var, const matrix44& Value);
	void			SetMatrixArray(HVar Var, const matrix44* pArray, DWORD Count);
	void			SetMatrixPointerArray(HVar Var, const matrix44** pArray, DWORD Count);
	void			SetTexture(HVar Var, const CTexture& Value);
	//pEffect->SetRawValue

	DWORD			Begin(bool SaveState);
	void			BeginPass(DWORD PassIdx);
	void			CommitChanges(); // For changes inside a pass
	void			EndPass();
	void			End();

	HTech			GetTechByFeatures(DWORD FeatureFlags) const;
	HTech			GetCurrentTech() const { return hCurrTech; }
	bool			SetTech(HTech hTech);
	HVar			GetVarHandleByName(CStrID Name) const;
	HVar			GetVarHandleBySemantic(CStrID Semantic) const;
	bool			HasVarByName(CStrID Name) const { return NameToHVar.FindIndex(Name) != INVALID_INDEX; }
	bool			HasVarBySemantic(CStrID Semantic) const { return SemanticToHVar.FindIndex(Semantic) != INVALID_INDEX; }
	bool			IsVarUsed(HVar hVar) const;
	ID3DXEffect*	GetD3D9Effect() const { return pEffect; }
};

typedef Ptr<CShader> PShader;

// Doesn't support arrays for now (no corresponding types)
inline bool CShader::Set(HVar Var, const Data::CData& Value)
{
	n_assert_dbg(Var && Value.IsValid());
	if (Value.IsA<bool>()) SetBool(Var, Value);
	else if (Value.IsA<int>()) SetInt(Var, Value);
	else if (Value.IsA<float>()) SetFloat(Var, Value);
	else if (Value.IsA<vector4>()) SetFloat4(Var, Value);
	else if (Value.IsA<matrix44>()) SetMatrix(Var, Value);
	else if (Value.IsA<CMatrixPtrArray>())
	{
		const CMatrixPtrArray& Array = Value.GetValue<CMatrixPtrArray>();
		SetMatrixPointerArray(Var, Array.Begin(), Array.GetCount());
	}
	else if (Value.IsA<PTexture>()) SetTexture(Var, *Value.GetValue<PTexture>());
	else FAIL;
	OK;
}
//---------------------------------------------------------------------

inline CShader::HTech CShader::GetTechByFeatures(DWORD FeatureFlags) const
{
	int Idx = FlagsToTech.FindIndex(FeatureFlags);
	return(Idx == INVALID_INDEX) ? NULL : FlagsToTech.ValueAt(Idx);
}
//---------------------------------------------------------------------

inline CShader::HVar CShader::GetVarHandleByName(CStrID Name) const
{
	int Idx = NameToHVar.FindIndex(Name);
	return (Idx == INVALID_INDEX) ? NULL : NameToHVar.ValueAt(Idx);
}
//---------------------------------------------------------------------

inline CShader::HVar CShader::GetVarHandleBySemantic(CStrID Semantic) const
{
	int Idx = NameToHVar.FindIndex(Semantic);
	return (Idx == INVALID_INDEX) ? NULL : SemanticToHVar.ValueAt(Idx);
}
//---------------------------------------------------------------------

}

#endif
